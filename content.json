{"meta":{"title":"yanna的blog","subtitle":"在这里记录学习与生活","description":"一个关于技术、代码、笔记和经验分享的个人博客。","author":"Yanna","url":"https://Yannnnnnna.github.io","root":"/"},"pages":[{"title":"","date":"2025-07-12T07:15:58.605Z","updated":"2025-07-12T07:07:50.220Z","comments":true,"path":"about/index.html","permalink":"https://yannnnnnna.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2025-07-12T06:54:51.000Z","updated":"2025-07-12T06:54:51.249Z","comments":true,"path":"archives/index.html","permalink":"https://yannnnnnna.github.io/archives/index.html","excerpt":"","text":""},{"title":"","date":"2025-07-12T07:37:33.653Z","updated":"2025-07-12T07:37:33.653Z","comments":true,"path":"404.html","permalink":"https://yannnnnnna.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"我的朋友们","date":"2025-07-12T07:16:17.575Z","updated":"2025-07-12T07:08:58.568Z","comments":true,"path":"friends/index.html","permalink":"https://yannnnnnna.github.io/friends/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2025-07-12T07:16:11.437Z","updated":"2025-07-12T07:08:09.172Z","comments":true,"path":"categories/index.html","permalink":"https://yannnnnnna.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-07-12T07:16:22.315Z","updated":"2025-07-12T07:08:37.349Z","comments":true,"path":"tags/index.html","permalink":"https://yannnnnnna.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"我的第一篇文章","slug":"我的第一篇文章","date":"2025-07-11T09:07:10.000Z","updated":"2025-07-12T08:18:44.278Z","comments":true,"path":"2025/07/11/我的第一篇文章/","permalink":"https://yannnnnnna.github.io/2025/07/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"","text":"问题 3：对比 CountDownLatch, CyclicBarrier, Semaphore 的适用场景。 通俗易懂解释： 把这三个工具想象成组织团队活动： CountDownLatch (倒数门栓) ：像一场“ 火箭发射 ”。主控中心（主线程）必须等待所有的准备工作（多个子线程，如燃料填充、设备检查）全部完成。每个子任务完成后就报告一次（ countDown() ），主控中心一直在等待（ await() ）。一旦所有报告都收到（计数器减到 0），火箭立刻发射。这个门栓是一次性的，用完就废了。 特点：一个或多个线程等待其他多个线程完成任务。一次性。 CyclicBarrier (循环栅栏) ：像组织一场“ 团队旅游 ”。约定好早上 8 点在公园门口集合，所有人（所有线程）必须到齐了，才能一起进公园玩。进公园后，大家又约定好中午 12 点在餐厅门口集合，到齐了再一起吃饭。这个“集合点”（栅栏）是可以 重复使用 的。 特点：一组线程相互等待，直到所有线程都到达一个公共的屏障点。可重用。 Semaphore (信号量) ：像一个“ 停车场 ”。停车场只有 3 个车位（3个许可证）。来了车（线程），就看有没有空位，有就进去（ acquire() ），许可证减 1。没空位就得在外面排队等着。有车离开（ release() ），许可证加 1，外面的车就可以进来一个。它关心的是“ 资源的数量够不够用 ”。 特点：控制同时访问特定资源的线程数量。用于流量控制或资源池管理。 面试中如何回答： CountDownLatch, CyclicBarrier, 和 Semaphore 是 java.util.concurrent 包下三个非常重要的并发协作工具，它们的适用场景有明显的区别： CountDownLatch (倒数计数器)：它用于一个线程等待一个或多个线程完成指定操作的场景。核心方法是 countDown() 和 await()。await() 方法会阻塞当前线程，直到计数器被 countDown() 方法减到 0。它的主要特点是一次性的，计数器值无法重置。典型的应用场景是，主线程需要等待所有子任务（如初始化、数据加载）执行完毕后再继续执行。 CyclicBarrier (循环屏障)：它用于一组线程相互等待，直到所有线程都到达一个共同的屏障点（barrier point），然后再一起继续执行。它比 CountDownLatch 更复杂和强大，因为它是可重用的（调用 reset() 方法）。当所有线程都调用了 await() 方法后，屏障被打破，所有线程被释放。还可以提供一个可选的 Runnable 任务，在屏障被打破时执行一次。适用于需要分阶段、同步执行多个线程任务的场景，比如多线程计算，每个阶段都依赖于上个阶段所有线程的计算结果。 Semaphore (信号量)：它用于控制对某个共享资源的同时访问的线程数量。通过一个计数器来维护可用许可证的数量。线程在访问资源前必须通过 acquire() 方法获取一个许可证，如果许可证数量为 0，则线程阻塞。访问完成后，通过 release() 方法释放许可证。它主要用于流量控制、限流，或者实现资源池，如数据库连接池。 总结一下：CountDownLatch 强调的是“等待”，一个等多个；CyclicBarrier 强调的是“同步”，多个等多个，且可循环；Semaphore 强调的是“限流”，控制并发数。 问题 4：如何用 CountDownLatch 实现“多线程下载文件，等全部下载完后再合并”？ 面试中如何回答： 使用 CountDownLatch 来实现多线程下载并合并文件的场景非常经典。具体步骤如下： 确定任务拆分：首先，我们需要根据文件大小和网络情况，决定将文件拆分成多少个部分进行下载，假设是 N 个部分。 初始化 CountDownLatch：创建一个 CountDownLatch 实例，并将计数器的初始值设置为 N。 final int N = 5; // 假设分成5个线程下载 CountDownLatch latch = new CountDownLatch(N); 创建并启动下载线程：创建 N 个下载线程，每个线程负责下载文件的一个独立部分。在每个下载线程的 run 方法中，执行下载逻辑。最关键的是，在下载任务完成之后，必须在 finally 块中调用 latch.countDown() 方法，确保即使下载过程中出现异常，计数器也能被正确地减少。Java for (int i = 0; i &lt; N; i++) &#123; final int part = i; new Thread(() -> &#123; try &#123; // 执行下载文件第 part 部分的逻辑... System.out.println(\"Part \" + part + \" downloaded.\"); &#125; finally &#123; latch.countDown(); // 每完成一个就计数减一 &#125; &#125;).start(); &#125; 主线程等待：在主线程中，启动了所有下载线程之后，立即调用 latch.await() 方法。主线程会在这里被阻塞，直到 latch 的计数器变为 0。Java System.out.println(\"Main thread is waiting for all parts to be downloaded...\"); latch.await(); // 阻塞，直到计数器为0 执行合并操作：一旦 latch.await() 返回（即所有下载线程都已完成），主线程就会被唤醒。此时，可以安全地执行后续的文件合并操作。Java System.out.println(\"All parts downloaded. Starting file merge...\"); // 执行合并N个下载好的文件块的逻辑... System.out.println(\"File merged successfully.\"); 通过这种方式，CountDownLatch 充当了一个可靠的协调者，确保了合并操作一定会在所有下载任务都完成之后才开始执行。","categories":[{"name":"分类1","slug":"分类1","permalink":"https://yannnnnnna.github.io/categories/%E5%88%86%E7%B1%BB1/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"https://yannnnnnna.github.io/tags/%E6%A0%87%E7%AD%BE1/"},{"name":"标签2","slug":"标签2","permalink":"https://yannnnnnna.github.io/tags/%E6%A0%87%E7%AD%BE2/"}]},{"title":"Hello World","slug":"hello-world","date":"2025-07-11T01:40:37.992Z","updated":"2025-07-11T01:40:37.992Z","comments":true,"path":"2025/07/11/hello-world/","permalink":"https://yannnnnnna.github.io/2025/07/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"分类1","slug":"分类1","permalink":"https://yannnnnnna.github.io/categories/%E5%88%86%E7%B1%BB1/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"https://yannnnnnna.github.io/tags/%E6%A0%87%E7%AD%BE1/"},{"name":"标签2","slug":"标签2","permalink":"https://yannnnnnna.github.io/tags/%E6%A0%87%E7%AD%BE2/"}]}